<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://s-bose.github.io/atom.xml" rel="self"/>
  
  <link href="https://s-bose.github.io/"/>
  <updated>2022-03-23T01:29:41.575Z</updated>
  <id>https://s-bose.github.io/</id>
  
  <author>
    <name>Shiladitya Bose</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>prototype-pattern</title>
    <link href="https://s-bose.github.io/2022/03/22/prototype-pattern/"/>
    <id>https://s-bose.github.io/2022/03/22/prototype-pattern/</id>
    <published>2022-03-22T17:49:04.000Z</published>
    <updated>2022-03-23T01:29:41.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Some questions first, we know that in order to implement polymorphism the right way, i.e, dynamic binding and LSP (Liskov Substitution Principle), we have to make the functions <code>virtual</code>, sometimes pure virtual, and then reimplement them in the Derived class with an <code>override</code> keyword.</p><p>We also need to separate the interface from the implementation, i.e, make the virtual function to be overriden <code>private</code>, and make a proxy <code>public</code> interface function in Base that simply calls the private function. We only need to reimplement the <code>private</code> <code>virtual</code> function in Derived. A simple example is shown below.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vCall</span><span class="params">()</span></span>; <span class="comment">// override in derived</span></span><br><span class="line"><span class="comment">// virtual void vCall() = 0; // pure virtual, if base has nothing to do</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Base::call</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vCall</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::vHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Base vHello called\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vHello</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::vHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Derived vHello called\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base *bp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base *bp1 = <span class="keyword">new</span> Base;</span><br><span class="line">bp-&gt;<span class="built_in">hello</span>(); <span class="comment">// Derived</span></span><br><span class="line">bp1-&gt;<span class="built_in">hello</span>(); <span class="comment">// Base</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is pretty standard when it comes to providing polymorphic support for some member functions. In addition, if Base class acquires some dynamic memory it also needs to free them, therefore providing a destructor, but the problem is, if Base only has a normal destructor, then using LSP, the Base pointer pointing to a Derived object, once out of scope, will trigger the destructor for Base class only, since there is no v_table entry for destructor, thus if Derived also has some dynamic allocation, they cannot be freed, leading to memory leak. Thus, we also have virtual destructors which work pretty much the same way.</p><h2 id="Virtual-Constructor"><a href="#Virtual-Constructor" class="headerlink" title="Virtual Constructor???"></a>Virtual Constructor???</h2><p>Well, it does not make sense. In order for virtual constructor to work, we need to have a v_ptr entry for the address of the constructor function.</p><p>but the constructor of a class should have the same type as the class itself. But at the time of construction, the type does not exist yet, as the class object hasn’t been created yet, so we don’t know what the v_ptr should point to, it creates a paradox.</p><p>At the same time, v_ptr and vtables are items instantiated for each class objects. There is no vtable before the object creation.</p><p>at the time of calling the constructor, <strong>the <a href="https://www.learncpp.com/cpp-tutorial/the-virtual-table/">virtual table</a> would not have been created</strong> to resolve any virtual function calls. Thus, a virtual constructor itself would not have anywhere to look up to.</p><p>Such is the reason why the variants of constructors, such as copy or move constructors also cannot be made virtual.</p><p>But we can get around that problem using Prototype design pattern. We want to be able to create copies of a Derived object through a Base ptr or ref to that Derived obj (using LSP).</p><p>In this protocol, we make the Base class an abstract base class (ABC), with atleast one pure virtual function, and it does not have a copy constructor.</p><p>Generally, it has two functions, a public interface <code>clone()</code> and a private pure virtual, <code>copy()</code> signalling reimplementation in Derived classes.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>(Base <span class="keyword">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Base</span>();</span><br><span class="line"><span class="function">Base *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Base *<span class="title">copy</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Base *<span class="title">Base::clone</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">copy</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not inline</span></span><br><span class="line">Base::~<span class="built_in">Base</span>()</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>We offer a Wrapper class over Base that provides the copy functionalities:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Base *d_bp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Wrapper</span>();</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Wrapper</span><span class="params">(Wrapper *bp)</span></span>;</span><br><span class="line">~<span class="built_in">Wrapper</span>();</span><br><span class="line"><span class="built_in">Wrapper</span>(Wrapper <span class="keyword">const</span> &amp;other);</span><br><span class="line"><span class="built_in">Wrapper</span>(Wrapper &amp;&amp;tmp);</span><br><span class="line">Wrapper &amp;<span class="keyword">operator</span>=(Wrapper <span class="keyword">const</span> &amp;other);</span><br><span class="line">Wrapper &amp;<span class="keyword">operator</span>=(Wrapper &amp;&amp;tmp);</span><br><span class="line"><span class="function">Base &amp;<span class="title">getBase</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Wrapper::Wrapper</span><span class="params">()</span></span></span><br><span class="line"><span class="function">:</span></span><br><span class="line"><span class="function">d_bp(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Wrapper::Wrapper</span><span class="params">(Wrapper *bp)</span></span></span><br><span class="line"><span class="function">:</span></span><br><span class="line"><span class="function">d_bp(bp)</span></span><br><span class="line"><span class="function">&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Wrapper::~<span class="built_in">Wrapper</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> d_bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Wrapper::Wrapper</span><span class="params">(Wrapper <span class="keyword">const</span> &amp;other)</span></span></span><br><span class="line"><span class="function">:</span></span><br><span class="line"><span class="function">d_bp(other.d_bp-&gt;clone())</span></span><br><span class="line"><span class="function">&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Wrapper::Wrapper</span><span class="params">(Wrapper &amp;&amp;tmp)</span></span></span><br><span class="line"><span class="function">:</span></span><br><span class="line"><span class="function">d_bp(tmp.d_bp)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">tmp.d_bp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Base &amp;<span class="title">Wrapper::getBase</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *d_bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Wrapper &amp;Wrapper::<span class="keyword">operator</span>=(Wrapper <span class="keyword">const</span> &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">Wrapper <span class="built_in">tmp</span>(other);</span><br><span class="line">std::<span class="built_in">swap</span>(d_bp, tmp.d_bp);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Wrapper &amp;Wrapper::<span class="keyword">operator</span>=(Wrapper &amp;&amp;tmp)</span><br><span class="line">&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(d_bp, tmp.d_bp);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The Wrapper class exists to provide a unified copy-able interface for the entire family that derives from Base, all the Derived class needs to do is implement its <code>virtual copy()</code> method to return a new pointer to a copy of <code>this</code> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">Derived</span>() <span class="keyword">override</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function">Base *<span class="title">copy</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Base *<span class="title">Derived::copy</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Derived</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="No-Copy-move-constructor-for-polymorphic-Base"><a href="#No-Copy-move-constructor-for-polymorphic-Base" class="headerlink" title="No Copy/move constructor for polymorphic Base?"></a>No Copy/move constructor for polymorphic Base?</h2><p>According to C++ guidelines, C.67, <strong><strong>A polymorphic class should suppress public copy/move</strong></strong></p><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-copy-virtual">C++ Core Guidelines</a></p><p>This is because, whenever the polymorphic Base class has implicitly defined copy/move constructors in place, </p><p>If it is accidentally passed by value, with the implicitly generated copy constructor and assignment, we risk slicing: only the base portion of a derived object will be copied, and the polymorphic behaviour will be corrupted.</p><p>This is why, we have to either delete the implicit copy/move constructor like we did in the last example, if the Base class does not have any data, or else make the constructors protected, so the copying can only be done from the context of Derived class.</p><p>For more example, the link is useful, check C.67 for this particular issue. –&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;Some questions first, we know </summary>
      
    
    
    
    <category term="programming" scheme="https://s-bose.github.io/categories/programming/"/>
    
    
    <category term="design pattern" scheme="https://s-bose.github.io/tags/design-pattern/"/>
    
    <category term="cpp" scheme="https://s-bose.github.io/tags/cpp/"/>
    
    <category term="inheritance" scheme="https://s-bose.github.io/tags/inheritance/"/>
    
  </entry>
  
  <entry>
    <title>A roadmap to CPP</title>
    <link href="https://s-bose.github.io/2022/02/12/second-post/"/>
    <id>https://s-bose.github.io/2022/02/12/second-post/</id>
    <published>2022-02-11T18:30:00.000Z</published>
    <updated>2022-03-23T01:21:25.571Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>C and more specifically, C++, have continued to be the running joke among the programming community, due to them being notoriously difficult to grasp, from the esoteric and weird syntax, the dreadful pointers and memory management (although that has gotten better), to templates and what not. Indeed they are not everyone’s cup of tea, and while it is true that languages like <a href="https://www.rust-lang.org/">Rust</a> are slowly starting to bridge the gap between code readability and code efficiency, C++ is still relevant and has a long way ahead, in areas such as Embedded Systems, Operating Systems, Kernel, or Driver development, Game development, Machine Learning, or basically any area where efficient and high-performant computing is required. Is it necessary to learn, or master C++ in 2022? Absolutely not, most of the modern languages provide a more than decent performance in most use-cases, and unless there is a specific need for performance, and other alternatives are for some reason not viable, you would be well-off without touching C++. But learning it, and learning it well is indeed a nice thing to have. Not only would you gain a clear understanding of the low-level internal workings, such as the memory management, the entire compilation process and the absolutely impressive workhorse that the C++ compiler is, you open up a new door to creativity, where you can start writing kernel modules, high-performant libraries, build your own compiler or interpreter and make your own programming language (and also the fact that you can flaunt your C++ superiority among your friends). The possibilities are endless. I’ve spent a good 4-5 months studying advanced C++, and even though I still don’t consider myself to be proficient in C++, I am fairly well-versed with the language at this stage. I am writing this guide to hopefully, not only help you but also help myself get better at C++ in the days to come. The guide is nowhere near perfect and I’m sure I’ll be missing a few important references here and there, but it has worked out for me so far, and I only hope it works out for you as well.</p><h2 id="Environments-amp-Prerequisites"><a href="#Environments-amp-Prerequisites" class="headerlink" title="Environments &amp; Prerequisites"></a>Environments &amp; Prerequisites</h2><p>I haven’t personally used MSVC C++ for Windows, so I can’t really form an opinion on how viable it is to learn C++ on Windows. However, with the addition of WSL you can use standard GNU G++ (gcc/g++) compilers on Windows. Personally, I use <a href="https://pop.system76.com/">Pop!OS</a>, an Ubuntu-based Linux distribution as my daily driver which comes with the default GNU G++ Compiler. I use version 11.2.0.</p><p>In order to get the most out of it, we need to have a compiler that supports the features from c++2020 standard.<br><a href="https://en.cppreference.com/w/cpp/compiler_support/20">This table</a> provides the list of all available compiler versions that support some or all features of C++20. Preferably, you should use the latest g++ version available with your Linux distro (or clang++ or MSVC).</p><p>Here is a list of prerequisites that I recommend:</p><table><thead><tr><th align="left">Item</th><th align="left">Description</th><th align="left">Version</th></tr></thead><tbody><tr><td align="left"><code>gcc/g++</code></td><td align="left">Compiler</td><td align="left"><code>&gt;=11.0</code></td></tr><tr><td align="left"><code>make/cmake</code></td><td align="left">Build utilities</td><td align="left"><code>&gt;=4.3, &gt;=3.18</code></td></tr><tr><td align="left"><code>vscode/vim/sublime-text</code></td><td align="left">Code Editor</td><td align="left"><code>Any</code></td></tr><tr><td align="left"><code>Rubber Duck</code></td><td align="left">Debugging</td><td align="left"><code>Any</code></td></tr></tbody></table><h2 id="Test-the-waters-with-C"><a href="#Test-the-waters-with-C" class="headerlink" title="Test the waters with C"></a>Test the waters with C</h2><p>As Linus Torvalds said, </p><blockquote><p>“<a href="https://www.youtube.com/watch?v=CYvJPra7Ebk">Nothing better than C…</a>“</p></blockquote><p>I do believe that in order to fully grasp C++, if you are coming from a completely different environment such as Python, or JavaScript and haven’t touched a penny of C/C++ in your life, then C should be the first stop before you venture further. Although C does not provide a lot of features that C++, or any of those obvious features that we take for granted, it is still the most effective and intensive way to learn the internal nitty-gritties of the compilation process.<br>The best book to accompany you in this scenario is <a href="https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628">The C Programming Language</a> by the creators of the language themselves.<br>Its a relatively short book, you should be fairly comfortable with the language environment in a few weeks.<br>If you’re interested in learning C++, I would suggest to not spend too much time mastering C but instead focus on the following key areas which only help you accelerate the learning process of C++.</p><h3 id="Key-Topics"><a href="#Key-Topics" class="headerlink" title="Key Topics"></a>Key Topics</h3><ul><li>C/C++ Compilation Process</li><li>Primitive Datatypes &amp; Bit Manipulation</li><li>Pointers &amp; Memory Management (Allocation, Dellocation)</li><li>Structs and Function Pointers</li></ul><h2 id="Chapter-1-Introduction-to-C"><a href="#Chapter-1-Introduction-to-C" class="headerlink" title="Chapter 1: Introduction to C++"></a>Chapter 1: Introduction to C++</h2><p>I have been learning C++ from <a href="http://www.icce.rug.nl/edu/">this course</a> offered by Dr. Frank B. Brokken and Prof. Jurjen Bokma of University of Groningen, and it is one of the most intensive and in-depth courses I have ever participated in. The course is divided into three parts, each taking around 2 months to complete. I would highly recommend to check out the course for further information.<br>Apart from that,I’ve thoroughly followed the book <a href="https://fbb-git.github.io/cppannotations/cppannotations/html/index.html">CPP Annotations</a>, written by Dr.Frank B. Brokken.</p><p>I would suggest <a href="https://fbb-git.github.io/cppannotations/cppannotations/html/index.html">CPP Annotations</a> to be the primary literature study, moving forward with C++.<br>Alternatively, <a href="https://www.amazon.com/C-Programming-Language-4th/dp/0321563840">The C++ Programming Language</a> by Bjarne Stroustrup, creator of C++ is also a good choice.<br>And last but not least, the <a href="https://en.cppreference.com/w/cpp/language">CppReference</a> is your friend.</p><p>I will provide the full list of bibliography at the end. What we will be mainly focusing on are the concepts and strategies in your learning.</p><p>In the following sections I will talk about topics that you would need to focus on that gets progressively complex to provide a streamlined approach in studying C++.</p><p><strong>Book Suggestions</strong></p><ul><li><a href="https://www.amazon.com/C-Programming-Language-4th/dp/0321563840">The C++ Programming Language</a> by Bjarne Stroustrup</li><li><a href="https://www.amazon.com/dp/1491903996/?_encoding=UTF8&pd_rd_w=qdkPa&pf_rd_p=9aa30bae-d685-4626-879d-c38f81e830a3&pf_rd_r=QFN3PY1WWZ9YMA0PEK4D&pd_rd_r=cb3e5711-cb4c-4f9b-99f2-647a071d3986&pd_rd_wg=7bcAU&ref_=bd_tags_dp_rec">Effective Modern C++</a> by Scott Meyers.</li></ul><h3 id="Namespaces-Streams-amp-Standard-Library"><a href="#Namespaces-Streams-amp-Standard-Library" class="headerlink" title="Namespaces, Streams &amp; Standard Library"></a>Namespaces, Streams &amp; Standard Library</h3><p>C++ has namespaces, a way to group together classes, functions and variable definitions from different sources under a single umbrella. The namespace <code>std</code> contains all the tools that are in the C++ standard. It is the named scope for all standard implementations of pretty much everything you would need for general-purpose programming, scattered across a number of different headers such as <code>&lt;iostream&gt;</code> (and their corresponding source files).<br>A header file provides an interface, a catalog of the things provided by a library, which are then implemented in separate source files. This header file oriented program structure should be recognized in great detail since this clear distinction between interface and implementation is at the heart of good C++ program design.<br>Objects like <code>cout</code>, or <code>cin</code> is a type of <code>stream</code>, which is a new concept in C++. Instead of having a specific function that prints to the console, the stream-based IO is more generic in the sense that we can write polymorphic code that can write to any <code>stream</code>, not just the console, alongside the fact that we can achieve almost the same task of formatted-strings with <code>cout</code>, as well as being <a href="https://stackoverflow.com/questions/17789396/how-cout-is-more-typesafe-than-printf">type-safe</a>.<br>You should spend some time studying the different types of <code>stream</code>s and their class-hierarchy since most of the IO happens over streams.</p><h3 id="Memory-Management-Pointers-amp-References"><a href="#Memory-Management-Pointers-amp-References" class="headerlink" title="Memory Management, Pointers &amp; References"></a>Memory Management, Pointers &amp; References</h3><p>C++, much like C, has manual garbage collection*, using <code>new</code> and <code>delete</code> and their variants. The key difference is that we don’t have to allocate raw memory and provide the size of the memory block. <code>new</code> and <code>delete</code> are more type-safe. Learning this new memory management is crucial in situations where you have to manage your own data. Consequently, pointers also play an important part. References are new to C++, which can be thought of as named aliases to another variable.</p><p><strong>Note</strong>*: There is a way to do automatic garbage allocation, known as RAII (Resource Allocation Is Initialization), it is a principle that is used to build most of the standard container classes, (and you can, too), which states that an object that is initialized with some allocated resource is in charge of that resource, and will relinquish the resource as soon as it goes out of scope (aka, destroyed).</p><h3 id="Types-Values-Macros-amp-Smart-Pointers"><a href="#Types-Values-Macros-amp-Smart-Pointers" class="headerlink" title="Types, Values, Macros &amp; Smart Pointers"></a>Types, Values, Macros &amp; Smart Pointers</h3><p>You need to understand primitive types, pointer-types, references, and rvalue references, their sizes in memory, their lifetimes and <code>cv-qualification (const-volatile)</code>.</p><p>C++ also has a number of value categories, such as:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">          glvalue    rvalue</span><br><span class="line">           /     \   /   \</span><br><span class="line">        lvalue  xvalue   rvalue        </span><br></pre></td></tr></table></figure><p>These are important to remember when considering copying and moving data.</p><p>Typecasting is required from time to time. Instead of using C-style castings, use <code>static_cast</code>, <code>reinterpret_cast</code>(dangerous), or <code>dynamic_cast</code>.</p><p>Avoid Macros, as they are not type-safe. Instead, use <code>constexpr</code>.<br>Use smart pointers, i.e, RAII-adhering wrapper classes such as <code>unique_ptr</code> or <code>shared_ptr</code>, whenever possible. </p><p>    </p><h3 id="Object-Oriented-Programming"><a href="#Object-Oriented-Programming" class="headerlink" title="Object Oriented Programming"></a>Object Oriented Programming</h3><p>The major advantage of C++ is its adaptation of Object-oriented programming.<br>Here are some of the things you need to remember when working with OOP in C++.</p><ul><li>Encapsulation &amp; data hiding is achieved via access specifiers such as <code>public</code>, <code>private</code>, and <code>protected</code>.</li><li>Have a clear separation between a class’s public interface &amp; private (or sometimes protected) implementations.</li><li>If you have to expose a data-member as public, if class-specific, make it <code>static</code> , else, provide public-getters to <code>private</code> data, don’t expose data members directly.</li><li>Function overloading/overriding is not Polymorphism, and it is achieved in compile-time by creating unique function signatures.</li><li>C++ has <strong>Inheritance</strong>, (and multiple inheritance). Inheriting from a Base class can be done through all three access-specifiers, although their behaviors vastly differ.</li><li><strong>Composition</strong> is another useful concept, and should be preferred over Inheritance to reduce code coupling.</li><li><strong>Polymorphism</strong> can be static (compile-time, using CRTP), or dynamic (run-time, using Vtables and Vptrs). The most common type of polymorphism, i.e, run-time is achieved via <code>virtual</code> method overriding, and then substituting a Base object with a Derived one to “polymorphize” the method, commonly known as Liskov Substitution Principle (LSP).</li><li><strong>Abstract Base Class (ABC)</strong> are used to further enforce dynamic polymorphism.</li><li>Learn about <code>friend</code>s, and free functions, (such as <code>operator&lt;&lt;</code>)</li></ul><h2 id="Chapter-2-Advanced-Topics"><a href="#Chapter-2-Advanced-Topics" class="headerlink" title="Chapter 2: Advanced Topics"></a>Chapter 2: Advanced Topics</h2><p>This section deals with some intermediate topics in C++.</p><p><strong>Book Suggestions</strong></p><ul><li><p><a href="https://www.amazon.com/Modern-Design-Generic-Programming-Patterns/dp/0201704315">Modern C++ Design: Generic Programming and Design Patterns</a> by Andrei Alexandrescu.</p></li><li><p><a href="https://www.amazon.com/Coding-Standards-Rules-Guidelines-Practices/dp/0321113586">C++ Coding Standards</a> by Andrei Alexandrescu.</p></li><li><p><a href="https://www.amazon.com/Exceptional-Engineering-Programming-Problems-Solutions/dp/0201615622/ref=sr_1_1?crid=PERBM6MENIUR&keywords=exceptional+c++&qid=1647878499&s=books&sprefix=exceptional+c+,stripbooks-intl-ship,408&sr=1-1">Exceptional C++</a> &amp; <a href="https://www.amazon.com/More-Exceptional-Engineering-Programming-Solutions/dp/020170434X/ref=sr_1_1?crid=1553V6BH6EB9N&keywords=more+exceptional+c++&qid=1647878523&s=books&sprefix=morexceptional+c++,stripbooks-intl-ship,343&sr=1-1">More Exceptional C++</a> by Herb Sutter.</p></li><li><p><a href="https://www.amazon.com/C-Concurrency-Action-Practical-Multithreading/dp/1933988770">C++ Concurrency in Action</a>, by Anthony Williams.</p></li></ul><h3 id="Standard-Containers-amp-Generic-Algorithms"><a href="#Standard-Containers-amp-Generic-Algorithms" class="headerlink" title="Standard Containers &amp; Generic Algorithms"></a>Standard Containers &amp; Generic Algorithms</h3><p>C++ <code>std::</code> provides a wide-range of tools to fit pretty much every need.<br>One of the most important are the containers, a bunch of well-defined standard data structure implementations such as <code>map</code>, <code>deque</code>, <code>vector</code>, etc. They are generic and provides a flexible and memory-safe interface for working with data.</p><p>Closely related are the generic algorithms, these are utility functions that work on any container type, such as <code>sort</code>, <code>copy</code>, <code>accumulate</code>, or <code>for_each</code>, which are preferable alternatives to reinventing wheel, and also reduces clutter in your project.</p><h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>Writing exception-safe code is not easy. In a language like C++ it is even more important, otherwise you risk getting extremely long unintelligible error messages, and memory leak.<br>There are certain functions in C++ that won’t ever throw exceptions, and there are some that might. You need to know which part of your code is exception-prone and handle it properly.<br>Exception handling is particularly crucial when you’re working with some form of resource which might remain in an inconsistent state once the exception occurs.<br>Writing your own exception class is also encouraged for better documentation and readability.</p><h3 id="Multithreading-Optional"><a href="#Multithreading-Optional" class="headerlink" title="Multithreading (Optional)"></a>Multithreading (Optional)</h3><p>Multithreading is not everyone’s cup of tea, due to it being difficult to wrap your head around, and the extra performance gain is not really that big of a deal given today’s hardware. However, if you want to get your hands dirty with multithreading, some of the useful libraries in C++ std are <code>thread</code>, <code>mutex</code>, and <code>chrono</code>. You have to spend some time learning about the inner workings of a multithreaded application, the lifecycle of a thread, hooks that you can use on the current thread, and preserving data integrity by using mutex locks.<br>This opens up a new door to asynchronous programming using <code>async</code>, <code>future</code> and <code>promise</code>, some of these terms might be familiar to people coming from JavaScript background.</p><h2 id="Chapter-3-More-Advanced-Topics"><a href="#Chapter-3-More-Advanced-Topics" class="headerlink" title="Chapter 3: More Advanced Topics"></a>Chapter 3: More Advanced Topics</h2><p>This section is all about templates. Templates are underrated but they can be extremely versatile and performant if used right. Templates are also <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670">Turing Complete</a> and there is a whole new domain called template metaprogramming just for that, where one does most of the computations during compile-time so that we end up with significantly less overhead in runtime.</p><p><strong>Book Suggestions</strong></p><ul><li><a href="https://www.amazon.com/Template-Metaprogramming-Concepts-Techniques-Beyond/dp/0321227255">C++ Template Metaprogramming</a> by David Abrahams.</li></ul><ul><li><a href="https://www.amazon.com/C-Templates-Complete-Guide-2nd/dp/0321714121">C++ Templates: The Complete Guide</a> by by David Vandevoorde, Nicolai Josuttis, Douglas Gregor.</li></ul><h3 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h3><p>Templates are recipes, or blueprints to constructing a class or a function given to the compiler for an arbitrary type. The class or function is only instantiated when the types are specified (broadly speaking, however there’s also Template Argument Deduction and other methods for instantiating templates). Standard containers like <code>std::vector</code> are examples of template classes.<br>You can use templates to write generic functions and classes. You can also specify non-type template arguments which are literal integral values of characters. Here are some of the topics that you need to study to get yourself properly introduced to templates.</p><ul><li>Learn about function template declarations and instantiations. </li><li>Template specialization, where you provide special-case implementation for a specific type.</li><li>Learn about template argument deduction and how compiler deduces the correct function signatures.</li><li><code>constexpr</code> and <code>consteval (CPP20)</code> and template variables.</li><li>Study class templates, and partial specializations.</li><li>Variadic templates.</li><li>Static Polymorphism using CRTP.</li></ul><h3 id="Template-Metaprogramming-Concepts"><a href="#Template-Metaprogramming-Concepts" class="headerlink" title="Template Metaprogramming, Concepts"></a>Template Metaprogramming, Concepts</h3><p>Metaprogramming is in my opinion the strongest feature that C++ provides. You can perform pretty much anything using template metaprogramming in compile-time. By using template recursion and base-case specialization you can rewrite iterations with a recursive call. To give you an idea, here is an implementation of fibonacci using metaprogramming.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> value = Fibonacci&lt; N<span class="number">-1</span> &gt;::value + Fibonacci&lt; N<span class="number">-2</span> &gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span>&lt;</span><span class="number">0</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span>&lt;</span><span class="number">1</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> value = <span class="number">1</span> &#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Concepts are introduced in C++20 that allow us some fine-grained control over which types we allow in our templates. This is useful for documenting exactly what your template needs (for example, you define custom iterative algorithm that works on any object that has a <code>begin()</code> and <code>end()</code> iterator).<br>You can also do compile-time type-checking, constrain the types you allow, use <code>&lt;type_traits&gt;</code> to check whether the template types satisfy certain conditions.<br>All of these only solidify your code structure so that most of the errors can be figured and fixed during compile-time (and also be readable, not become a 200 line long clutter) and the runtime runs flawlessly.<br>Another reason why metaprogramming is important is to reduce the computation overhead for computing runtime constants which can be done in compile-time.<br>An amazing example of metaprogramming I found recently is <a href="https://github.com/Morwenn/static_math">static_math</a>, which I highly recommend taking a look at.</p><h2 id="Chapter-4-Outside-C"><a href="#Chapter-4-Outside-C" class="headerlink" title="Chapter 4: Outside C++"></a>Chapter 4: Outside C++</h2><p>Here I have compiled a bunch of resources, not directly related to C++ that might be beneficial to know alongside. Some of these are integral to development in general, like learning UNIX/Linux.</p><ul><li>Learning UNIX/Linux. <a href="https://web.mit.edu/~simsong/www/ugh.pdf">Unix Hater’s Handbook</a> is a good reference.</li><li>Knowing design patterns. The original <a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">Gang-of-four</a> is incomparable, however the language in the book is a bit hard to grasp IMO. A really good website I recently found is <a href="https://refactoring.guru/design-patterns">this one</a> that explains the design patterns with beautiful visualizations and easy-to-follow explanations, which I’d recommend.</li></ul><h2 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h2><p>Since you’ve come this far, I thank you for your patience. After all these studying and grinding you might be wondering where to go from there (or you might not, maybe you’ve already decided, good for you). The answer to that is, <strong>projects</strong>, and not just now, you need to keep building small mini-projects from the start and gradually increase in complexity and scale. C++ is a messy language, and not keeping in touch with the language for long enough will make even the most versatile C++ programmer succumb. </p><p>Two of the go-to places for finding project ideas as well as tutorials are:</p><ol><li><a href="https://github.com/practical-tutorials/project-based-learning">https://github.com/practical-tutorials/project-based-learning</a></li><li><a href="https://github.com/danistefanovic/build-your-own-x">https://github.com/danistefanovic/build-your-own-x</a></li></ol><p>They’re filled with language-specific tutorials and I’d highly recommend you to spend some time on these.</p><p>Subreddit <a href="https://www.reddit.com/r/cpp">r/cpp</a> is also filled with interesting discussions about C++, new community-created projects to get inspired from, and in general get help from. Stackoverflow is also good but I would advise against asking questions there and simply look for your questions that’s already been answered, if you’re just beginning, chances are, someone already faced the issue.</p><p><a href="https://news.ycombinator.com/">HackerNews</a> is a forum for technology and you’ll find cool articles or project showcases every now and then.</p><p>Overall, the internet is bigger and better than ever with almost every resource at your disposal. If you’re starting off with serious intention of mastering C++, you will need to accept the weirdness of a really old language and keep the train moving. Only by doing stuffs, building projects, solving exercises, asking questions, and actively engaging can you finally be able to write a really cool kernel module that nobody understands but, hopefully, help land a rover on Mars. And as  Shia LaBeouf once said:</p><p><img src="https://media.giphy.com/media/HJPhN12JVDe4o/giphy.gif" alt="just do it"></p>]]></content>
    
    
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;A step-by-step guide for learning Modern C++ in 2022&lt;/p&gt;</summary>
    
    
    
    <category term="programming" scheme="https://s-bose.github.io/categories/programming/"/>
    
    
    <category term="cpp" scheme="https://s-bose.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://s-bose.github.io/2022/01/01/hello-world/"/>
    <id>https://s-bose.github.io/2022/01/01/hello-world/</id>
    <published>2021-12-31T18:30:00.000Z</published>
    <updated>2022-03-23T01:20:22.876Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote><p>“Aller Angfang ist schwer”</p></blockquote><p>I made a sort of promise to myself this year that I will stop procrastinating and start my personal blog. So I did, sort of. Its still a bit rough around the edges, I just started working with Gatsby and after browsing a number of different static-site generators and even more templates the exhaustion got the better of me, and I finally settled down with <a href="https://hexo.io/">Hexo</a> and <a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak">Tranquilpeak</a> theme.<br>I assume this must have some sort of special significance when the first blog-post is on New Year’s Eve, and I guess there is some truth to that. </p><p>Now, you might have questions, such as;</p><h2 id="What-do-I-write"><a href="#What-do-I-write" class="headerlink" title="What do I write?"></a>What do I write?</h2><p>Pretty much everything. This is a piece of myself. I’m not really the expressive kind but I try my best. I am a computer scientist and software engineer, and I have interest in many areas, such as Data Science, Machine Learning, Statistics, Mathematics, Cryptography, Software engineering and design patterns, but also Music, Linguistics, History, Literature, Politics, Astronomy, and pretty much everything that piques the interest of my hyperactive brain time-to-time. I know, Jack of all trades or something along the lines.</p><p>So, to sum up, I would post about my old and new projects, how I did what I did, how I didn’t what I didn’t, and how it could be done better, as a reminder to myself that to err is human, and also to anyone who stumbled upon the jumbled up mess and hopefully also learn how to do what I did, and maybe do it better. But also I would post about things in the regular mundane life that interest me, that movie that I just watched, that book that I had finally finished after a year of dreadful stare-down between the book and I, or that little rant about how much I hate the fact that humanity went to space not because of some greater cause but because of the fear of nuclear annihilation.</p><p>So yeah, pretty diverse. Hope you don’t mind.</p><h2 id="Who-am-I"><a href="#Who-am-I" class="headerlink" title="Who am I?"></a>Who am I?</h2><p>I’m Batman. For more info, check out <a href="http://github.com/s-bose">this</a>.</p><h2 id="What-is-the-answer-to-life-the-universe-and-everything"><a href="#What-is-the-answer-to-life-the-universe-and-everything" class="headerlink" title="What is the answer to life, the universe and everything?"></a>What is the answer to life, the universe and everything?</h2><p>Before answering that, ask yourself this question, would knowing that answer rid us of the existential dread of humanity, the misery of poverty, depression, cancer and all the rational and irrational phobias of earthly and unearthly objects,<br>and most importantly, would it help you sleep any better? The answer is 四̴̡̰̗͕͈̜̖̲̝̝̠̩̤͓̦͉̗̇̉͆̅́二̷̛̮͖̬̼͓̝͕̝̲̩̞̠̳̯̥̤͓̃̓̾̎͊̓̽̅͋͌͂͝</p><h2 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h2><p>That was mildly over-expressive for a first post, but stay tuned for more. I’ll try to post weekly, hopefully arrange a newsletter in the future if this gains some traction. Till then, I guess I’ll see you around, random internet traveller!</p><p>See you soon! 😀<br>Auf Wiedersehen!</p>]]></content>
    
    
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;First Post&lt;/p&gt;</summary>
    
    
    
    <category term="general" scheme="https://s-bose.github.io/categories/general/"/>
    
    
    <category term="blog" scheme="https://s-bose.github.io/tags/blog/"/>
    
    <category term="first post" scheme="https://s-bose.github.io/tags/first-post/"/>
    
  </entry>
  
</feed>
